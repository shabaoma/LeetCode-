# 求和
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 2sum | dict + loop | 1 |  |
| 3sum | seen + 2 pointers | 15 | i从左往右，j从i+1往右。往seen添加-(nums[i] + nums[j])，对照新的nums[j]是否在seen里 |
| k-sum |  |  |  |

# 二叉树
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 全部路径 | 递归 | 257 | 每一层更新一次path，如果到叶节点（left和right都为空），就把path加入到答案中，如果不是，就把将path传给下一层。 |
| 最短树枝 | bfs | 111 |  |
| sorted list -> binary tree | 将list分成2个等长list -> 递归 | 108 |  |

# 链表
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| Reverse |  | 206 | * |
| 合并已排序链表 | 递归 | 21 | 只比较l1.value, l2.value。重新定义l1.next和l2.next |

# 数组
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 合并区间 | 排序 + 遍历 | 56 | 按照左边从小到大排序。第一次或者下一个坐标的左边比区间的右边大，说明不重叠，要append进答案里。不然就是重合的，更新答案就可以了。 |

# 子数组
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 最大子数组 | 贪心 or dp | 53 | 局部最优解比较的是curr_sum = max(nums[i], curr_sum + nums[i]); dp[i] = max(nums[i], dp[i-1] + nums[i]) |
| 和为K的子数组的数量 | dict | 560 | 用dict记录到目前为止的和出现的次数。用这个和-target，如果存在就说明存在某种情况，这个数组的某一位加上target的情况存在。 |

# 子字符串
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 最长不重复子字符串 | seen + Sliding Window | 3 | 遍历条件for i < n and j < n。j往右，如果没有发现重复字母，j++。如果发现了已有字符串，就说明窗口要缩小了，i++。 |
| 最长元音子字符串长度 | dp + Sliding Window | 1456 | 用dp记住每一段中元音的个数，然后滑动窗口到底。 |

# 回文
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 判断是否是回文 |  | 125 | s == s[::-1] |
| 判断排列组合是否有回文的可能 |  |  | sum(v % 2 for v in collections.Counter(s).values()) < 2 |
| 最长回文 | dp + 2 pointers | 5 | i从右往左，j从i往右。如果dp[i+1][j-1]是回文且s[i]==s[j]，则dp[i][j]也是回文。 |

# 有效路径
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| ['(', ')', '{', '}', '[', ']'] | stack | 20 |  |

# 二维数组
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 数岛数 | queue + bfs | 200 | q = queue.Queue(); q.put(); q.get()，每次遇到新的岛，计数器+1。然后四方向探索把那座岛变成0。 |
| 烂橘子会传染 | deque + bfs | 994 | q = collections.deque ; q.popleft(); q.append(); q用来保存烂橘子的初始位置。从烂橘子开始4方向探索，如果找到新鲜橘子，则添加那个橘子，深度+1。将那个橘子变成烂橘子。|

# 构造
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| [0, 1, 00, 01, 10, 11, ...] | queue + bfs | LT | 元素少可以遍历 |
| [1, 2] -> find(any(sum([11, 12, 21, 22]))) == n | dfs + 做减法 | 39 | 元素多需要减枝 |
| [123, 132, 213, 231, 312, 321] | 回溯 | 77 | append & pop |
| 用[a, b]构造"ababa" |  | 139 |  |
| (), (()), ((())), ()(), ()(()) | 回溯 | 22 | left < n说明还要添加左括号，right < left说明右括号比左括号少，要加右括号。 |

# 数学
| 类型 | 算法提示 | 题号 | 笔记 |
| :-- | :-- | :-- | :-- |
| 求除自己外其余数字的乘积 | 错位相乘 | 238 | 从左边开始算，直到自己所有数字的乘积。再从右边开始乘，乘的时候跳过自己。 |
