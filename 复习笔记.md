# 求和
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 2sum | dict + loop | 1 |  |
| 3sum | seen + 2 pointers | 15 | i从左往右，j从i+1往右。往seen添加-(nums[i] + nums[j])，对照新的nums[j]是否在seen里 |
| k-sum |  |  |  |

# 二叉树
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 最短树枝 | bfs | 111 |  |
| sorted list -> binary tree | 将list分成2个等长list -> 递归 | 108 |  |

# 链表
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 合并已排序链表 | 递归 | 21 | 只比较l1.value, l2.value。重新定义l1.next和l2.next |

# 子数组
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 最大子数组 | 贪心 or dp | 53 | 局部最优解比较的是curr_sum = max(nums[i], curr_sum + nums[i]); dp[i] = max(nums[i], dp[i-1] + nums[i]) |

# 子字符串
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 最长不重复子字符串 | seen + Sliding Window | 3 | 遍历条件for i < n and j < n。j往右，如果没有发现重复字母，j++。如果发现了已有字符串，就说明窗口要缩小了，i++。 |

# 回文
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 最长回文 | dp + 2 pointers | 5 | i从右往左，j从i往右。如果dp[i+1][j-1]是回文且s[i]==s[j]，则dp[i][j]也是回文。 |

# 有效路径
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| ['(', ')', '{', '}', '[', ']'] | stack | 20 |  |

# 二维数组
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| 数岛数 | queue + bfs | 200 | q = queue.Queue(); q.put(); q.get()，每次遇到新的岛，计数器+1。然后四方向探索把那座岛变成0。 |
| 烂橘子会传染 | deque + bfs | 994 | q = collections.deque ; q.popleft(); q.append(); q用来保存烂橘子的初始位置。从烂橘子开始4方向探索，如果找到新鲜橘子，则添加那个橘子，深度+1。将那个橘子变成烂橘子。|

# 构造
| 类型 | 算法提示 | 题号 | 备注 |
| :-- | :-- | :-- | :-- |
| [0, 1, 00, 01, 10, 11, ...] | queue + bfs | LT | 元素少可以遍历 |
| [1, 2] -> find(any(sum([11, 12, 21, 22]))) == n | dfs + 做减法 | 39 | 元素多需要减枝 |
| [123, 132, 213, 231, 312, 321] | 回溯 | 77 | append & pop |
| 用[a, b]构造"ababa" |  | 139 |  |
| (), (()), ((())), ()(), ()(()) | 回溯 | 22 | left < n说明还要添加左括号，right < left说明右括号比左括号少，要加右括号。 |
